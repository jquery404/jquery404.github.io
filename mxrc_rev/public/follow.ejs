<!DOCTYPE html>
<html lang="en">
<head>

	<style>
		video{
		position: absolute;
		top: 0;
		width: 200px;
		border: 1px solid;
		margin: 1em;
		}
		.mystyle{position: absolute;top:0;right: 0;}
	</style>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
	<script src="https://unpkg.com/aframe-environment-component@1.2.0/dist/aframe-environment-component.min.js"></script>
	<script src="https://unpkg.com/super-hands/dist/super-hands.min.js"></script>
	<script src="<%= _url %>/scripts/diffCam.js"></script>
	<script src="<%= _url %>/scripts/comp-shader-wave.js"></script>
	<script src="<%= _url %>/scripts/comp-shader-zoom.js"></script>
	<script src="<%= _url %>/scripts/comp-shader-outline.js"></script>
    <script>

	var coordinates = AFRAME.utils.coordinates;
	var isCoordinates = coordinates.isCoordinates || coordinates.isCoordinate;

    AFRAME.registerComponent('look-at', {
	  schema: {
	    tar: {
			default: '0 0 0',

			parse: function (value) {
				if (isCoordinates(value) || typeof value === 'object') {
					return coordinates.parse(value);
				}
				return value;
			},

			stringify: function (data) {
				if (typeof data === 'object') {
					return coordinates.stringify(data);
				}
				return data;
			}
		},

		speed: {default: 0.01}
	  },

	  init: function () {
	    this.target3D = null;
	    this.vector = new THREE.Vector3();
	    this.cameraListener = AFRAME.utils.bind(this.cameraListener, this);
	    this.el.addEventListener('componentinitialized', this.cameraListener);
	    this.el.addEventListener('componentremoved', this.cameraListener);
	  },

	  /**
	   * If tracking an object, this will be called on every tick.
	   * If looking at a position vector, this will only be called once (until further updates).
	   */
	  update: function () {
	    var self = this;
	    var target = self.data.tar;
	    var targetEl;

	    // No longer looking at anything (i.e., look-at="").
	    if (!target || (typeof target === 'object' && !Object.keys(target).length)) {
	      return self.remove();
	    }

	    // Look at a position.
	    if (typeof target === 'object') {
	      return this.lookAt(new THREE.Vector3(target.x, target.y, target.z));
	    }

	    // Assume target is a string.
	    // Query for the element, grab its object3D, then register a behavior on the scene to
	    // track the target on every tick.
	    targetEl = self.el.sceneEl.querySelector(target);
	    if (!targetEl) {
	      warn('"' + target + '" does not point to a valid entity to look-at');
	      return;
	    }
	    if (!targetEl.hasLoaded) {
	      return targetEl.addEventListener('loaded', function () {
	        self.beginTracking(targetEl);
	      });
	    }
	    return self.beginTracking(targetEl);
	  },

	  tick: (function () {
	    var vec3 = new THREE.Vector3();

		const pos = new THREE.Vector3();
        const rot = new THREE.Quaternion();
		const matrix = new THREE.Matrix4();
		
	    return function (t) {
	      // Track target object position. Depends on parent object keeping global transforms up
	      // to state with updateMatrixWorld(). In practice, this is handled by the renderer.
	      var target3D = this.target3D;
	      if (target3D) {
	        target3D.getWorldPosition(vec3);
	        this.lookAt(vec3);

			// pos.setFromMatrixPosition(target3D.matrixWorld); // Vector3
			// rot.setFromRotationMatrix(matrix.extractRotation(target3D.matrixWorld));
				
			// var debug = document.getElementById("debug");
			// debug.setAttribute("value", "Positionsss: " + pos.x + " " + pos.y + " " + pos.z + " ," + "Rotationss: " + rot.x + " " + rot.y + " " + rot.z);

	      }

		  
	    }
	  })(),

	  remove: function () {
	    this.el.removeEventListener('componentinitialized', this.cameraListener);
	    this.el.removeEventListener('componentremoved', this.cameraListener);
	  },

	  beginTracking: function (targetEl) {
	    this.target3D = targetEl.object3D;
	  },

	  cameraListener: function (e) {
	    if (e.detail && e.detail.name === 'camera') {
	      this.update();
	    }
	  },

	  lookAt: function (position) {
	    var vector = this.vector;
	    var object3D = this.el.object3D;
		var speed = this.data.speed;

	    if (this.el.getObject3D('camera')) {
	      vector.subVectors(object3D.position, position).add(object3D.position);
	    } else {
	      vector.copy(position);
	    }

        //let npos = new THREE.Vector3(position.x-1, position.y-1, position.z-1);
        object3D.lookAt(vector);
        //object3D.position.lerp(npos, .01);

		const distanceFromCamera = 3; 
		var target3D = this.target3D;
		const target = new THREE.Vector3(0, 0, -distanceFromCamera);
		target.applyMatrix4(target3D.matrixWorld);    
		
		const distance = object3D.position.distanceTo(target);
		if (distance > 0) {
			// const amount = Math.min(moveSpeed * deltaTime, distance) / distance;
			object3D.position.lerp(target, speed);
		} 
	  }
	});
	
	
	AFRAME.registerComponent('track-camera', {
		schema: {
	    	target: {default: []},
		},

		init: function(){
			this.target = this.data.target;
		},

		update: function(){
			this.target = this.data.target;
		},

        tick: (function () {
          const position = new THREE.Vector3();
          const rotation = new THREE.Quaternion();
		  const direction = new THREE.Vector3();
          const euler = new THREE.Euler();
          const matrix = new THREE.Matrix4();
          return function () {
			
            this.el.object3D.updateMatrixWorld();
            position.setFromMatrixPosition(this.el.object3D.matrixWorld); // Vector3
            rotation.setFromRotationMatrix(matrix.extractRotation(this.el.object3D.matrixWorld ));
			var e = this.el.object3D.matrixWorld.elements;
            direction.set(e[8], e[9], e[10]).normalize();
            
            // var debug = document.getElementById("debug");
			// debug.setAttribute("value", "Position: " + position.x.toFixed(2) + " " + position.y.toFixed(2) + " " + position.z.toFixed(2) + " ," + "Rotation: " + rotation.x.toFixed(2) + " " + rotation.y.toFixed(2) + " " + rotation.z.toFixed(2) + " ," + "Direction: " + direction.x.toFixed(2) + " " + direction.y.toFixed(2) + " " + direction.z.toFixed(2));

			
			// target tracking
			this.target.forEach((elem, i) => {
				var target3D = this.el.sceneEl.querySelector(elem).object3D;	
				if (target3D) {
					this.lookAt(target3D, position, i);
				}
			});
          }
        })(),

		lookAt: function(obj, pos, i){
			obj.lookAt(pos);
			const distanceFromCamera = 3; 
			// const target = new THREE.Vector3(i*-3 + 1, 0, -distanceFromCamera);
			const target = new THREE.Vector3(i*-1 + 1, 0, -distanceFromCamera); // 1, 0, -1
			// const target = new THREE.Vector3(0, 0, -distanceFromCamera-i*.05); // 1, 0, -1
			target.applyMatrix4(this.el.object3D.matrixWorld);    
			
			const distance = obj.position.distanceTo(target);
			if (distance > 0) {
				// const amount = Math.min(moveSpeed * deltaTime, distance) / distance;
				obj.position.lerp(target, 0.05 + i/100*4);
			} 
		}
      });

	</script>
</head>
<body>

	<a-scene vr-mode-ui="enabled: false">
        <a-assets>
        <img id="grid" src="img/grid.png">
        <img id="sky" src="img/sky.jpg" />
		<%- include('_ass_hud'); %>
        </a-assets>
		<a-entity id="mouseCursor" cursor="rayOrigin: mouse"></a-entity>
        <a-entity id="player" camera track-camera="target:#camel,#horse,#chicken" position="0 1.6 0" wasd-controls look-controls></a-entity>

		<a-plane id="camel" mixin="plane" class="hud" width="1" height="1" rotation="90 0 0"></a-plane>
		<a-plane id="horse" mixin="plane" class="hud" width="1" height="1" color="#343434" rotation="90 0 0"></a-plane>
		<a-plane id="chicken" material="shader:outline; uMap: #broadcaster;isActive:true" mixin="plane" class="hud" width="1" height="1" rotation="90 0 0"></a-plane>
		

        <a-entity position="0 0 0"
        geometry="primitive: plane; width: 10000; height: 10000;" rotation="-90 0 0"
        material="src: #grid; repeat: 10000 10000; transparent: true; metalness:0.6; roughness: 0.4; sphericalEnvMap: #sky;"></a-entity>

		<!-- <a-plane postion="0 -2 0" 
			width="25" height="40" 
			rotation="-90 180 -90" 
			segments-height="100" 
			segments-width="100" 
			material="shader:makewaves; uMap: #sky; repeat: 500 500;"></a-plane> -->

        <a-sky src="#broadcaster" rotation="0 -90 0"></a-sky>
    </a-scene>
	
	<%- include('_device_list'); %>
    <video id="broadcaster" class="host" playsinline autoplay muted></video>
	<!-- <span id="score" style="position:absolute;top:50%;left: 50%;font-size:3em;color:white;">0</span> -->

	<div class="params" style="position: absolute;bottom:0; left:0">
		<input type="checkbox" id="pointer" name="pointer" value="">
		<label for="pointer"> Pointer</label><br>
		<input type="checkbox" id="drawing" name="drawing" value="">
		<label for="drawing"> Drawing</label><br>
		<input type="checkbox" id="gesture" name="gesture" value="">
		<label for="gesture"> Gesture</label><br> 
	</div>


    <pre></pre>
	
	<script src="scripts/rtcconfig.js"></script>
	<script src="scripts/jquery-latest.min.js"></script>
    <script>
		// Get camera and microphone
        const videoElement = document.querySelector(".host");
        const videoTwoElement = document.querySelector(".host2");
        const audioSelect = document.querySelector("select#audioSource");
        const videoSelect = document.querySelector("select#videoSource");
        const video = document.querySelector("#video2");
        let canvas;
        let toggle;

        audioSelect.onchange = getStream;
        videoSelect.onchange = getStream;

        getStream().then(getDevices).then(gotDevices);

        function getStream() {
            if (window.stream) {
                window.stream.getTracks().forEach(track => {
                    track.stop();
                });
            }
            const audioSource = audioSelect.value;
            const videoSource = videoSelect.value;
            const constraints = {
            audio: false,
            video: { deviceId: videoSource ? { exact: videoSource } : undefined }
            };
            return navigator.mediaDevices
            .getUserMedia(constraints)
            .then(gotStream)
            .catch(handleError);
        }

        function gotStream(stream) {
            window.stream = stream;
            audioSelect.selectedIndex = [...audioSelect.options].findIndex(
            option => option.text === stream.getAudioTracks()[0].label
            );
            videoSelect.selectedIndex = [...videoSelect.options].findIndex(
            option => option.text === stream.getVideoTracks()[0].label
            );
            videoElement.srcObject = stream;
            videoElement.play();
            
            localStream = stream;
        }

        function handleError(error) {
            console.error("Error: ", error);
        }

        function getDevices() {
            return navigator.mediaDevices.enumerateDevices();
        }

        function gotDevices(deviceInfos) {
            window.deviceInfos = deviceInfos;
            for (const deviceInfo of deviceInfos) {
            const option = document.createElement("option");
            option.value = deviceInfo.deviceId;
            if (deviceInfo.kind === "audioinput") {
                option.text = deviceInfo.label || `Microphone ${audioSelect.length + 1}`;
                audioSelect.appendChild(option);
            } else if (deviceInfo.kind === "videoinput") {
                option.text = deviceInfo.label || `Camera ${videoSelect.length + 1}`;
                videoSelect.appendChild(option);
            }
            }
        }


		// motion canvas
		let isReadyToDiff = false;
		var score = document.getElementById('score');
		var motionCanvas = document.createElement("canvas");
		motionCanvas.width = 200;
		motionCanvas.height = 80;
		motionCanvas.classList.add("mystyle");
		var motionContext = motionCanvas.getContext('2d');
		document.body.appendChild(motionCanvas);


		// function initSuccess() {
		// 	DiffCamEngine.start();
		// }

		// function initError() {
		// 	alert('Something went wrong.');
		// }

		var justchecked = false;
		function capture(payload) {
			// if(payload.score>100 && !justchecked){
			// 	score.textContent = "Switch";
			// 	videoElement.pause();
			// 	setTimeout(()=> {
			// 		justchecked = true;
			// 		videoElement.play();
			// 		setTimeout(()=> {
			// 			justchecked = false;
			// 		}, 5000)
			// 	}, 5000)
			// }
			// else{
				score.textContent = "Inactive " + payload.score;
			//}
		}

		// DiffCamEngine.init({
		// 	video: videoElement,
		// 	motionCanvas: motionCanvas,
		// 	initSuccessCallback: initSuccess,
		// 	initErrorCallback: initError,
		// 	captureCallback: capture
		// });


		// options
		let pointerEl = document.querySelector('#pointer');
		let drawEl = document.querySelector('#drawing');
		let gestureEl = document.querySelector('#gesture');
		
		let isFlickering = false;
		
		function flicker(){
			if(isFlickering) return;

			var startTime = new Date().getTime();
			let isActive = false;

			var interval = setInterval(function(){
				isFlickering = true;
				isActive = !isActive;
				document.querySelector('#camel').setAttribute('material', 'isActive:'+isActive);
				if(new Date().getTime() - startTime > 2000){
					document.querySelector('#camel').setAttribute('material', 'isActive:false');
					clearInterval(interval);
					isFlickering = false;
					return;
				}
			},500);
		}
		


	</script>
</body>
</html>