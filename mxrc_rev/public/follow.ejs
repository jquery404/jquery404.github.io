<!DOCTYPE html>
<html lang="en">
<head>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
	<script src="https://unpkg.com/super-hands/dist/super-hands.min.js"></script>
    <script>

	var coordinates = AFRAME.utils.coordinates;
	var isCoordinates = coordinates.isCoordinates || coordinates.isCoordinate;

    AFRAME.registerComponent('look-at', {
	  schema: {
	    tar: {
			default: '0 0 0',

			parse: function (value) {
				if (isCoordinates(value) || typeof value === 'object') {
					return coordinates.parse(value);
				}
				return value;
			},

			stringify: function (data) {
				if (typeof data === 'object') {
					return coordinates.stringify(data);
				}
				return data;
			}
		},

		speed: {default: 0.01}
	  },

	  init: function () {
	    this.target3D = null;
	    this.vector = new THREE.Vector3();
	    this.cameraListener = AFRAME.utils.bind(this.cameraListener, this);
	    this.el.addEventListener('componentinitialized', this.cameraListener);
	    this.el.addEventListener('componentremoved', this.cameraListener);
	  },

	  /**
	   * If tracking an object, this will be called on every tick.
	   * If looking at a position vector, this will only be called once (until further updates).
	   */
	  update: function () {
	    var self = this;
	    var target = self.data.tar;
	    var targetEl;

	    // No longer looking at anything (i.e., look-at="").
	    if (!target || (typeof target === 'object' && !Object.keys(target).length)) {
	      return self.remove();
	    }

	    // Look at a position.
	    if (typeof target === 'object') {
	      return this.lookAt(new THREE.Vector3(target.x, target.y, target.z));
	    }

	    // Assume target is a string.
	    // Query for the element, grab its object3D, then register a behavior on the scene to
	    // track the target on every tick.
	    targetEl = self.el.sceneEl.querySelector(target);
	    if (!targetEl) {
	      warn('"' + target + '" does not point to a valid entity to look-at');
	      return;
	    }
	    if (!targetEl.hasLoaded) {
	      return targetEl.addEventListener('loaded', function () {
	        self.beginTracking(targetEl);
	      });
	    }
	    return self.beginTracking(targetEl);
	  },

	  tick: (function () {
	    var vec3 = new THREE.Vector3();

		const pos = new THREE.Vector3();
        const rot = new THREE.Quaternion();
		const matrix = new THREE.Matrix4();
		
	    return function (t) {
	      // Track target object position. Depends on parent object keeping global transforms up
	      // to state with updateMatrixWorld(). In practice, this is handled by the renderer.
	      var target3D = this.target3D;
	      if (target3D) {
	        target3D.getWorldPosition(vec3);
	        this.lookAt(vec3);

			// pos.setFromMatrixPosition(target3D.matrixWorld); // Vector3
			// rot.setFromRotationMatrix(matrix.extractRotation(target3D.matrixWorld));
				
			// var debug = document.getElementById("debug");
			// debug.setAttribute("value", "Positionsss: " + pos.x + " " + pos.y + " " + pos.z + " ," + "Rotationss: " + rot.x + " " + rot.y + " " + rot.z);

	      }

		  
	    }
	  })(),

	  remove: function () {
	    this.el.removeEventListener('componentinitialized', this.cameraListener);
	    this.el.removeEventListener('componentremoved', this.cameraListener);
	  },

	  beginTracking: function (targetEl) {
	    this.target3D = targetEl.object3D;
	  },

	  cameraListener: function (e) {
	    if (e.detail && e.detail.name === 'camera') {
	      this.update();
	    }
	  },

	  lookAt: function (position) {
	    var vector = this.vector;
	    var object3D = this.el.object3D;
		var speed = this.data.speed;

	    if (this.el.getObject3D('camera')) {
	      vector.subVectors(object3D.position, position).add(object3D.position);
	    } else {
	      vector.copy(position);
	    }

        //let npos = new THREE.Vector3(position.x-1, position.y-1, position.z-1);
        object3D.lookAt(vector);
        //object3D.position.lerp(npos, .01);

		const distanceFromCamera = 3; 
		var target3D = this.target3D;
		const target = new THREE.Vector3(0, 0, -distanceFromCamera);
		target.applyMatrix4(target3D.matrixWorld);    
		
		const distance = object3D.position.distanceTo(target);
		if (distance > 0) {
			// const amount = Math.min(moveSpeed * deltaTime, distance) / distance;
			object3D.position.lerp(target, speed);
		} 
	  }
	});
    

    
	AFRAME.registerComponent('track-camera', {
		schema: {
	    	target: {default: []},
		},

		init: function(){
			this.target = this.data.target;
		},

		update: function(){
			this.target = this.data.target;
		},

        tick: (function () {
          const position = new THREE.Vector3();
          const rotation = new THREE.Quaternion();
		  const direction = new THREE.Vector3();
          const euler = new THREE.Euler();
          const matrix = new THREE.Matrix4();
          return function () {
			
            this.el.object3D.updateMatrixWorld();
            position.setFromMatrixPosition(this.el.object3D.matrixWorld); // Vector3
            rotation.setFromRotationMatrix(matrix.extractRotation(this.el.object3D.matrixWorld ));
			var e = this.el.object3D.matrixWorld.elements;
            direction.set(e[8], e[9], e[10]).normalize();
            
            var debug = document.getElementById("debug");
			debug.setAttribute("value", "Position: " + position.x.toFixed(2) + " " + position.y.toFixed(2) + " " + position.z.toFixed(2) + " ," + "Rotation: " + rotation.x.toFixed(2) + " " + rotation.y.toFixed(2) + " " + rotation.z.toFixed(2) + " ," + "Direction: " + direction.x.toFixed(2) + " " + direction.y.toFixed(2) + " " + direction.z.toFixed(2));

			
			// target tracking
			this.target.forEach((elem, i) => {
				var target3D = this.el.sceneEl.querySelector(elem).object3D;	
				if (target3D) {
					this.lookAt(target3D, position, i);
				}
			});
          }
        })(),

		lookAt: function(obj, pos, i){
			obj.lookAt(pos);
			const distanceFromCamera = 3; 
			const target = new THREE.Vector3(i*-3 + 1, 0, -distanceFromCamera);
			target.applyMatrix4(this.el.object3D.matrixWorld);    
			
			const distance = obj.position.distanceTo(target);
			if (distance > 0) {
				// const amount = Math.min(moveSpeed * deltaTime, distance) / distance;
				obj.position.lerp(target, 0.05 + i/100*4);
			} 
		}
      });

	</script>
</head>
<body>

    <a-scene>
		<a-assets>
			<%- include('_ass_hud'); %>
			<img id="paint" src="<%= _url %>/img/ico_paint.jpg" />
			<img id="shoot" src="<%= _url %>/img/ico_shoot.jpg" />
		</a-assets>
		
		<a-entity  id="rhand" 
            laser-controls="hand: right" 
            mixin="hud-interactable"
            raycaster="objects: .hud; lineColor: #00FFFF; far: 1000">
        </a-entity>
	
        <a-entity position="-4 4 -8" look-at="tar: #player; speed: .01">
            <a-cone height=".25" color="#C388A3" radius-bottom="0.5" radius-top="0" rotation="90 0 0"></a-cone>
        </a-entity>

		<a-entity id="horse" position="-2 2 -4">
            <a-circle src="#shoot" radius=".5" rotation="0 0 0"></a-circle>
        </a-entity>

		<a-entity id="camel" position="-1 2 -5">
            <a-plane src="#paint" rotation="0 0 0"></a-plane>
        </a-entity>

		<a-entity position="-0 0 -6">
            <a-cone mixin="plane" class="hud" height=".25" color="#9900DD" radius-bottom="0.5" radius-top="0" rotation="90 0 0"></a-cone>
        </a-entity>
		<a-text id="debug" value="Hello World" color="red" position="0 2 -5" scale="2 2 2"></a-text>

        <a-box width="1" mixin="plane" class="hud" depth="1" height="1" color="#4CC3D9" position="-4 0 -2"></a-box>
        <a-camera track-camera id="player" position="0 1.6 0"></a-camera>
        <!-- <a-camera track-camera="target: #horse, #camel" id="player" position="0 1.6 0"></a-camera> -->
		<!-- <a-entity id="player" camera position="0 1.6 0" look-controls></a-entity> -->
    </a-scene>

</body>
</html>