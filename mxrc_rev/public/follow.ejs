<!DOCTYPE html>
<html lang="en">
<head>

	<style>
		video{
		position: absolute;
		top: 0;
		width: 200px;
		border: 1px solid;
		margin: 1em;
		}
	</style>
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
	<script src="https://unpkg.com/super-hands/dist/super-hands.min.js"></script>
    <script>

	var coordinates = AFRAME.utils.coordinates;
	var isCoordinates = coordinates.isCoordinates || coordinates.isCoordinate;

    AFRAME.registerComponent('look-at', {
	  schema: {
	    tar: {
			default: '0 0 0',

			parse: function (value) {
				if (isCoordinates(value) || typeof value === 'object') {
					return coordinates.parse(value);
				}
				return value;
			},

			stringify: function (data) {
				if (typeof data === 'object') {
					return coordinates.stringify(data);
				}
				return data;
			}
		},

		speed: {default: 0.01}
	  },

	  init: function () {
	    this.target3D = null;
	    this.vector = new THREE.Vector3();
	    this.cameraListener = AFRAME.utils.bind(this.cameraListener, this);
	    this.el.addEventListener('componentinitialized', this.cameraListener);
	    this.el.addEventListener('componentremoved', this.cameraListener);
	  },

	  /**
	   * If tracking an object, this will be called on every tick.
	   * If looking at a position vector, this will only be called once (until further updates).
	   */
	  update: function () {
	    var self = this;
	    var target = self.data.tar;
	    var targetEl;

	    // No longer looking at anything (i.e., look-at="").
	    if (!target || (typeof target === 'object' && !Object.keys(target).length)) {
	      return self.remove();
	    }

	    // Look at a position.
	    if (typeof target === 'object') {
	      return this.lookAt(new THREE.Vector3(target.x, target.y, target.z));
	    }

	    // Assume target is a string.
	    // Query for the element, grab its object3D, then register a behavior on the scene to
	    // track the target on every tick.
	    targetEl = self.el.sceneEl.querySelector(target);
	    if (!targetEl) {
	      warn('"' + target + '" does not point to a valid entity to look-at');
	      return;
	    }
	    if (!targetEl.hasLoaded) {
	      return targetEl.addEventListener('loaded', function () {
	        self.beginTracking(targetEl);
	      });
	    }
	    return self.beginTracking(targetEl);
	  },

	  tick: (function () {
	    var vec3 = new THREE.Vector3();

		const pos = new THREE.Vector3();
        const rot = new THREE.Quaternion();
		const matrix = new THREE.Matrix4();
		
	    return function (t) {
	      // Track target object position. Depends on parent object keeping global transforms up
	      // to state with updateMatrixWorld(). In practice, this is handled by the renderer.
	      var target3D = this.target3D;
	      if (target3D) {
	        target3D.getWorldPosition(vec3);
	        this.lookAt(vec3);

			// pos.setFromMatrixPosition(target3D.matrixWorld); // Vector3
			// rot.setFromRotationMatrix(matrix.extractRotation(target3D.matrixWorld));
				
			// var debug = document.getElementById("debug");
			// debug.setAttribute("value", "Positionsss: " + pos.x + " " + pos.y + " " + pos.z + " ," + "Rotationss: " + rot.x + " " + rot.y + " " + rot.z);

	      }

		  
	    }
	  })(),

	  remove: function () {
	    this.el.removeEventListener('componentinitialized', this.cameraListener);
	    this.el.removeEventListener('componentremoved', this.cameraListener);
	  },

	  beginTracking: function (targetEl) {
	    this.target3D = targetEl.object3D;
	  },

	  cameraListener: function (e) {
	    if (e.detail && e.detail.name === 'camera') {
	      this.update();
	    }
	  },

	  lookAt: function (position) {
	    var vector = this.vector;
	    var object3D = this.el.object3D;
		var speed = this.data.speed;

	    if (this.el.getObject3D('camera')) {
	      vector.subVectors(object3D.position, position).add(object3D.position);
	    } else {
	      vector.copy(position);
	    }

        //let npos = new THREE.Vector3(position.x-1, position.y-1, position.z-1);
        object3D.lookAt(vector);
        //object3D.position.lerp(npos, .01);

		const distanceFromCamera = 3; 
		var target3D = this.target3D;
		const target = new THREE.Vector3(0, 0, -distanceFromCamera);
		target.applyMatrix4(target3D.matrixWorld);    
		
		const distance = object3D.position.distanceTo(target);
		if (distance > 0) {
			// const amount = Math.min(moveSpeed * deltaTime, distance) / distance;
			object3D.position.lerp(target, speed);
		} 
	  }
	});
	
	
	AFRAME.registerComponent('track-camera', {
		schema: {
	    	target: {default: []},
		},

		init: function(){
			this.target = this.data.target;
		},

		update: function(){
			this.target = this.data.target;
		},

        tick: (function () {
          const position = new THREE.Vector3();
          const rotation = new THREE.Quaternion();
		  const direction = new THREE.Vector3();
          const euler = new THREE.Euler();
          const matrix = new THREE.Matrix4();
          return function () {
			
            this.el.object3D.updateMatrixWorld();
            position.setFromMatrixPosition(this.el.object3D.matrixWorld); // Vector3
            rotation.setFromRotationMatrix(matrix.extractRotation(this.el.object3D.matrixWorld ));
			var e = this.el.object3D.matrixWorld.elements;
            direction.set(e[8], e[9], e[10]).normalize();
            
            var debug = document.getElementById("debug");
			debug.setAttribute("value", "Position: " + position.x.toFixed(2) + " " + position.y.toFixed(2) + " " + position.z.toFixed(2) + " ," + "Rotation: " + rotation.x.toFixed(2) + " " + rotation.y.toFixed(2) + " " + rotation.z.toFixed(2) + " ," + "Direction: " + direction.x.toFixed(2) + " " + direction.y.toFixed(2) + " " + direction.z.toFixed(2));

			
			// target tracking
			this.target.forEach((elem, i) => {
				var target3D = this.el.sceneEl.querySelector(elem).object3D;	
				if (target3D) {
					this.lookAt(target3D, position, i);
				}
			});
          }
        })(),

		lookAt: function(obj, pos, i){
			obj.lookAt(pos);
			const distanceFromCamera = 3; 
			const target = new THREE.Vector3(i*-3 + 1, 0, -distanceFromCamera);
			target.applyMatrix4(this.el.object3D.matrixWorld);    
			
			const distance = obj.position.distanceTo(target);
			if (distance > 0) {
				// const amount = Math.min(moveSpeed * deltaTime, distance) / distance;
				obj.position.lerp(target, 0.05 + i/100*4);
			} 
		}
      });

	</script>
</head>
<body>

    <a-scene>
		<a-assets>
			<%- include('_ass_hud'); %>
			<img id="paint" src="<%= _url %>/img/ico_paint.jpg" />
			<img id="shoot" src="<%= _url %>/img/ico_shoot.jpg" />
		</a-assets>
		
		<a-entity  id="rhand" 
            laser-controls="hand: right" 
            mixin="hud-interactable"
            raycaster="objects: .hud; lineColor: #00FFFF; far: 1000">
        </a-entity>
	
        <a-entity position="-4 4 -8" look-at="tar: #player; speed: .01">
            <a-cone height=".25" color="#C388A3" radius-bottom="0.5" radius-top="0" rotation="90 0 0"></a-cone>
        </a-entity>

		<a-entity id="horse" position="-2 2 -4">
            <a-circle src="#shoot" radius=".5" rotation="0 0 0"></a-circle>
        </a-entity>

		<a-entity id="camel" position="-1 2 -5">
            <a-plane src="#paint" rotation="0 0 0"></a-plane>
        </a-entity>

		<a-entity position="-0 0 -6">
            <a-cone mixin="plane" class="hud" height=".25" color="#9900DD" radius-bottom="0.5" radius-top="0" rotation="90 0 0"></a-cone>
        </a-entity>
		<a-text id="debug" value="Hello World" color="red" position="0 2 -5" scale="2 2 2"></a-text>

        <a-box width="1" mixin="plane" class="hud" depth="1" height="1" color="#4CC3D9" position="-4 0 -2"></a-box>
        <!-- <a-camera track-camera id="player" position="0 1.6 0"></a-camera> -->
        <a-camera track-camera="target: #horse, #camel" id="player" position="0 1.6 0"></a-camera>
		<!-- <a-entity id="player" camera position="0 1.6 0" look-controls></a-entity> -->
    </a-scene>
	
	<video class="host" playsinline autoplay muted></video>

	<script src="scripts/jquery-latest.min.js"></script>
    <script>
		let localStream = null;
		let canvas;
		let stream;
		const videoElement = document.querySelector(".host");

		canvas = document.querySelector('canvas');
		canvas.getContext('2d');
        stream = canvas.captureStream(25);
        videoElement.srcObject = stream;
		localStream = stream;
		
		document.addEventListener('keydown', (e) => {
			if (e.code === "Space") {
				
				let wd = 64;
				let ht = 48;
				let isReadyToDiff = false;
				let pixelDiffThreshold = 32;
				
				let diffCanvas = document.createElement('canvas');
				diffCanvas.width = wd;
				diffCanvas.height = ht;
				let diffContext = diffCanvas.getContext('2d');
				diffContext.globalCompositeOperation = 'difference';
				diffContext.drawImage(videoElement, 0, 0, 300, 200);
				var diffImageData = diffContext.getImageData(0, 0, 300, 200);
				
				var rgba = diffImageData.data;
				
				var score = 0;
				var motionPixels = [];
				var motionBox = undefined;

				for (var i = 0; i < rgba.length; i += 4) {
					var pixelDiff = rgba[i] * 0.3 + rgba[i + 1] * 0.6 + rgba[i + 2] * 0.1;
					var normalized = Math.min(255, pixelDiff * (255 / pixelDiffThreshold));
					rgba[i] = 0;
					rgba[i + 1] = normalized;
					rgba[i + 2] = 0;

					if (pixelDiff >= pixelDiffThreshold) {
						score++;
						let coords = calculateCoordinates(i / 4);
						motionBox = calculateMotionBox(motionBox, coords.x, coords.y);
						motionPixels = calculateMotionPixels(motionPixels, coords.x, coords.y, pixelDiff);
					}
				}

				let motionCanvas = document.createElement('canvas');
				motionCanvas.width = wd;
				motionCanvas.height = ht;
				let motionContext = motionCanvas.getContext('2d');
				motionContext.putImageData(diffImageData, 0, 0);
				motionContext.strokeStyle = '#fff';
				motionContext.strokeRect(
					motionBox.x.min + 0.5,
					motionBox.y.min + 0.5,
					motionBox.x.max - motionBox.x.min,
					motionBox.y.max - motionBox.y.min
				);
				diffContext.globalCompositeOperation = 'source-over';
				diffContext.drawImage(video, 0, 0, wd, ht);

			}
		});
		

		function calculateCoordinates(pixelIndex) {
			return {x: pixelIndex % wd, y: Math.floor(pixelIndex / wd)};
		}

		function calculateMotionBox(currentMotionBox, x, y) {
			var motionBox =  currentMotionBox;

			motionBox.x.min = Math.min(motionBox.x.min, x);
			motionBox.x.max = Math.max(motionBox.x.max, x);
			motionBox.y.min = Math.min(motionBox.y.min, y);
			motionBox.y.max = Math.max(motionBox.y.max, y);

			return motionBox;
		}

		function calculateMotionPixels(motionPixels, x, y, pixelDiff) {
			motionPixels[x] = motionPixels[x];
			motionPixels[x][y] = true;

			return motionPixels;
		}


	</script>
</body>
</html>