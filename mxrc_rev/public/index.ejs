<!DOCTYPE html>
<html lang="en">
<head>
    <%- include('_head'); %>
</head>
<body>

    <a-scene vr-mode-ui="enabled: false">
        <a-assets>
        <img id="grid" src="img/grid.png">
        <img id="sky" src="img/sky.jpg" />
        </a-assets>

        <!-- <a-entity id="player" camera position="0 0 0" wasd-controls look-controls></a-entity> -->

        <a-entity position="0 0 0"
        geometry="primitive: plane; width: 10000; height: 10000;" rotation="-90 0 0"
        material="src: #grid; repeat: 10000 10000; transparent: true; metalness:0.6; roughness: 0.4; sphericalEnvMap: #sky;"></a-entity>

        <a-sky src="#broadcaster" rotation="0 0 0"></a-sky>
    </a-scene>

   
    <%- include('_device_list'); %>
    <video id="broadcaster" class="host" playsinline autoplay muted></video>
    <pre></pre>

    
    <script src="scripts/rtcconfig.js"></script>
    <script src="scripts/jquery-latest.min.js"></script>
    <script>

        let localStream = null;
        let localStream2 = null;
        let peers = {}
        let streams = []
        let clients = {sender: {tag: '', socket_id: ''}, receiver: []}
        let myId;

        // Get camera and microphone
        const videoElement = document.querySelector(".host");
        const videoTwoElement = document.querySelector(".host2");
        const audioSelect = document.querySelector("select#audioSource");
        const videoSelect = document.querySelector("select#videoSource");
        const video = document.querySelector("#video2");
        let canvas;
        let toggle;

        audioSelect.onchange = getStream;
        videoSelect.onchange = getStream;

        getStream().then(getDevices).then(gotDevices);

        function getStream() {
            if (window.stream) {
                window.stream.getTracks().forEach(track => {
                    track.stop();
                });
            }
            const audioSource = audioSelect.value;
            const videoSource = videoSelect.value;
            const constraints = {
            audio: false,
            video: { deviceId: videoSource ? { exact: videoSource } : undefined }
            };
            return navigator.mediaDevices
            .getUserMedia(constraints)
            .then(gotStream)
            .catch(handleError);
        }

        function gotStream(stream) {
            window.stream = stream;
            audioSelect.selectedIndex = [...audioSelect.options].findIndex(
            option => option.text === stream.getAudioTracks()[0].label
            );
            videoSelect.selectedIndex = [...videoSelect.options].findIndex(
            option => option.text === stream.getVideoTracks()[0].label
            );
            videoElement.srcObject = stream;
            videoElement.play();
            
            localStream = stream;
            
            init();
        }

        function handleError(error) {
            console.error("Error: ", error);
        }

        function getDevices() {
            return navigator.mediaDevices.enumerateDevices();
        }

        function gotDevices(deviceInfos) {
            window.deviceInfos = deviceInfos;
            for (const deviceInfo of deviceInfos) {
            const option = document.createElement("option");
            option.value = deviceInfo.deviceId;
            if (deviceInfo.kind === "audioinput") {
                option.text = deviceInfo.label || `Microphone ${audioSelect.length + 1}`;
                audioSelect.appendChild(option);
            } else if (deviceInfo.kind === "videoinput") {
                option.text = deviceInfo.label || `Camera ${videoSelect.length + 1}`;
                videoSelect.appendChild(option);
            }
            }
        }
    
        // .................................................
        // ................................................
        const socket = io.connect(window.location.origin);

        function init() {
            myId = socket.id;

            socket.emit('join room');

            socket.on('other joined', (socket_id) => {
                console.log(socket_id, ' joined')
                peers[socket_id] = addPeer(socket_id, true);
                localStream.getTracks().forEach(track => streams.push(peers[socket_id].addTrack(track, localStream)))
            })

            socket.on('offer', (socket_id, description) => {
                console.log(socket_id, ' make peer', description)
                clients.receiver.push({socket_id: socket_id, tag: description.tag});
                
                peers[socket_id] = addPeer(socket_id, false)
            
                peers[socket_id].setRemoteDescription(description.localDescription)
                    .then(() => { localStream.getTracks().forEach(track => streams.push(peers[socket_id].addTrack(track, localStream))); })
                    .then(() => peers[socket_id].createAnswer())
                    .then(sdp => peers[socket_id].setLocalDescription(sdp))
                    .then(() => {
                        console.log('received offer preparing ans for ', socket_id, peers[socket_id].localDescription.type)
                        let newLocalDescription = {tag: 'main', localDescription: peers[socket_id].localDescription};
                        clients.sender = {socket_id: myId, tag: newLocalDescription.tag};
                        socket.emit('answer', socket_id, newLocalDescription);
                    });
            })

            socket.on('answer', (socket_id, description) => {
                console.log('received ans back from ', socket_id);
                clients.receiver.push({socket_id: socket_id, tag: description.tag});
                peers[socket_id].setRemoteDescription(description.localDescription);
            })

            socket.on('candidate', (socket_id, candidate) => {
                if (socket_id in peers) {
                    console.log('received candidate from ', socket_id);
                    peers[socket_id].addIceCandidate(new RTCIceCandidate(candidate));
                }
            
            //peers[socket_id].addIceCandidate(new RTCIceCandidate(candidate)).catch(e => console.error(e));
            })
        
            socket.on('remove peer', (socket_id) => {
                console.log(socket_id, ' left')
                removePeer(socket_id)
            })

        }

        function removePeer(socket_id) {
            if (peers[socket_id]) {
                peers[socket_id].close();
                peers[socket_id].onicecandidate = null; 
                delete peers[socket_id];
            }

            document.querySelector("pre").innerHTML += socket_id + ' left\n';
        }

        function addPeer(socket_id, am_initiator) {
            const peers = new RTCPeerConnection(config);

            peers.onicecandidate = event => {
                if (event.candidate) {
                    console.log(socket_id, ' needs candidate');
                    socket.emit('candidate', socket_id, event.candidate);
                }
            };
            
            peers.ontrack = event => {
                //socket.emit('video', {sid: localStream.id})
            };

            if (am_initiator === true) {
                peers.onnegotiationneeded = () => {
                    peers.createOffer()
                    .then(sdp => peers.setLocalDescription(sdp))
                    .then(() => { 
                        let newLocalDescription = {tag: 'main', localDescription: peers.localDescription};
                        clients.sender = {socket_id: myId, tag: newLocalDescription.tag};
                        console.log('making offer to ', socket_id, peers.localDescription.type)
                        socket.emit('offer', socket_id, newLocalDescription); 
                    });
                };
            }

            return peers;
        }
    
    </script>

</body>
</html>