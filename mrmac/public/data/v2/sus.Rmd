---
title: "SUS"
author: "jquery404"
output: html_notebook
---

1. Original SUS / repharsed 
    + Would use system frequently?
    + System unnecessarily complex?
    + **System easy to use?**
    + Need technical support?
    + Functions well integrated?
    + System inconsistent?
    + Quick to learn system?
    + System cumbersome to use?
    + Confident using system?
    + Steep learning curve?
2. Subscale
    + Q1. The system made it easier to complete my collaborative task.
    + Q2. I found the system's features were straightforward to understand.
    + Q3. I found the system has steep learning curve.	
    + Q4. I found the most of the features confusing.

```{r}
# library
library(ggplot2)
library(ggpubr)
library(dplyr)
library(likert) 

coloring = c("#E76469", "#F8D85E","#EDA645","#D1B0B3","#8C99A6","#ADD299","#4FA490","#3B7F9F")
fontsize = 14

data=read.csv('csv/sus.csv', sep=",")
data <- as.data.frame(data) 
data[5:8] <- lapply(data[5:8], factor, levels=1:5, labels=c("Strongly Disagree", "Disagree", "Neutral","Agree","Strongly Agree"))
likt <- likert(data[,c(5:8)], grouping = data$conditions)

plot(likt, colors = c("#E76469", "#F8D85E","#EDA645","#4FA490","#3B7F9F")) + 
  theme_bw() +
  theme(axis.line = element_blank(),
        axis.title.x=element_blank(),
        axis.title.y=element_blank(),
        axis.text.x = element_text(color="black", size=fontsize),
        axis.text.y = element_text(color="black", size=fontsize),
        strip.text = element_text(color="black", size = fontsize),
        strip.background = element_blank(),
        text = element_text(size=fontsize),
        panel.border = element_blank(),
        plot.background = element_blank(),
        plot.margin = unit(c(0.005, .025, 1, 0), "null"),
        legend.title=element_blank(),
        legend.direction="horizontal",
        legend.position = c(.5, -.1),
        legend.justification = c("center", "top"))

ggsave("out/usability.pdf", width = 6.5, height = 4, dpi = 1000)
```

## Lets calculate the descriptive statistics

```{r}
data=read.csv('csv/sus.csv', sep=",")
my_summary <- data %>%
  group_by(conditions, role) %>%
  summarize(
    Mean = mean(sus_score),
    Median = median(sus_score),
    SD = sd(sus_score),
    Min = min(sus_score),
    Max = max(sus_score)
  )

# Print the table
my_summary
```

```{r}

df=read.csv('csv/sus.csv', sep=",")
condition_order <- c("C1", "C2", "C3")
df$conditions <- factor(df$conditions, levels = condition_order)

x_order <- c("VR", "AR")
df$role <- factor(df$role, levels = x_order)

stats <- df %>%
  group_by(role) %>%
  wilcox_test(sus_score~conditions, p.adjust.method = 'holm', paired = TRUE) %>%
  add_significance("p") %>%
  add_xy_position(x = "role")

tukey <- df %>% 
  tukey_hsd(sus_score ~ role) %>% 
  add_significance() %>% 
  add_xy_position()

bxp <- ggplot(df, aes(x = role, y = sus_score)) + 
  stat_boxplot(aes(fill = conditions), geom = "errorbar", width = 0.2, position = position_dodge(dodge)) +
  geom_boxplot(aes(fill = conditions), width = dodge, coef = 0, outlier.alpha = 0, show.legend = F) +
  stat_summary(aes(fill = conditions), fun.y = mean, 
               geom= "point", shape = 4, size = 5, colour= "black", 
               position = position_dodge(width = dodge)) +
  stat_summary(aes(fill = conditions), fun = median,
               geom = "crossbar", fatten = .1, width = .4*dodge, color = "black",
               position = position_dodge(width = dodge)) +
  labs(x = NULL, y = NULL) + 
  scale_fill_manual(name= "conditions", values = coloring) +
  scale_color_manual(name = "conditions", values = coloring) +
  stat_pvalue_manual(stats, label = 'p.adj.signif', hide.ns = TRUE, tip.length = 0.02) +
  annotation_custom(grid::linesGrob(y = c(0,0), gp = grid::gpar(lwd=3))) +
  geom_vline(xintercept=c(0.5,1.5,2.5,3.5,4.5,5.5,6.5,7.5),color="#F2F2F2")+ 
  theme_bw() + 
  theme(
    axis.line = element_blank(),
    axis.title.x=element_blank(),
    axis.title.y=element_blank(),
    axis.text.x = element_text(color="black", size=fontsize),
    axis.text.y = element_text(color="black", size=fontsize),
    text = element_text(size=fontsize),
    strip.background = element_blank(),
    plot.background = element_blank(),
    plot.margin = unit(c(0.005, .025, 0, 0), "null"),
    panel.border = element_blank(),
    panel.spacing = unit(c(0, 0, 0, 0), "null"),
    panel.grid.major.x = element_blank(),
    legend.key = element_blank(),
    legend.key.size = unit(1, "cm"),
    legend.key.height = unit(1.5, 'cm'), 
    legend.key.width = unit(1, 'cm'), 
    legend.position="none",
    legend.direction = "horizontal",
    legend.justification = c("center", "top"),
    legend.title=element_blank(),
    legend.text=element_text(size=fontsize),
    legend.box.just = "right",
    legend.box.background = element_blank()
  ) + 
  guides(fill = guide_legend(override.aes = list(color = "transparent")))

bxp

# saving the final figure
ggsave("out/usability.pdf", bxp, width = 6, height =4, dpi = 1000)

```


Task completion time

```{r}
data=read.csv('csv/TaskCompletionTime.csv', sep=",")

# Create the box plot
boxplot_data <- gather(data, key = "C", value = "value", -group)

# Plot the box plot
ggplot(boxplot_data, aes(x = C, y = value)) +
  geom_boxplot() +
  stat_boxplot(aes(fill = C), geom = "errorbar", width = 0.2, position = position_dodge(dodge)) +
  geom_boxplot(aes(fill = C), width = dodge, coef = 0, outlier.alpha = 0, show.legend = F) +
  stat_summary(aes(fill = C), fun.y = mean, 
               geom= "point", shape = 4, size = 5, colour= "black", 
               position = position_dodge(width = dodge)) +
  stat_summary(aes(fill = C), fun = median,
               geom = "crossbar", fatten = .1, width = .4*dodge, color = "black",
               position = position_dodge(width = dodge)) +
  scale_fill_manual(name= "conditions", values = coloring) +
  scale_color_manual(name = "conditions", values = coloring) +
  xlab(NULL) +
  ylab("Time (seconds)") +
  theme_minimal()+
  theme(
    axis.line = element_blank(),
    axis.title.x=element_blank(),
    axis.text.x = element_text(color="black", size=fontsize),
    axis.text.y = element_text(color="black", size=fontsize),
    text = element_text(size=fontsize),
    strip.background = element_blank(),
    plot.background = element_blank(),
    plot.margin = unit(c(0.005, .025, 0, 0), "null"),
    panel.border = element_blank(),
    panel.spacing = unit(c(0, 0, 0, 0), "null"),
    panel.grid.major.x = element_blank(),
    legend.key = element_blank(),
    legend.key.size = unit(1, "cm"),
    legend.key.height = unit(1.5, 'cm'), 
    legend.key.width = unit(1, 'cm'), 
    legend.position="none",
    legend.direction = "horizontal",
    legend.justification = c("center", "top"),
    legend.title=element_blank(),
    legend.text=element_text(size=fontsize),
    legend.box.just = "right",
    legend.box.background = element_blank()
  ) + 
  guides(fill = guide_legend(override.aes = list(color = "transparent")))


# saving the final figure
ggsave("out/TaskCompletionTime.pdf", width = 4, height =4, dpi = 1000)



```




## Run ANOVA then Tukey's post-hoc test

```{r}
my_anova <- aov(sus_score ~ task, data = data)
my_tukey <- TukeyHSD(my_anova)


anova_table <- anova(my_anova)
F_val <- anova_table$F[1]
df1 <- anova_table$Df[1]
df2 <- anova_table$Df[2]

# print the results
summary(my_anova)
cat("F(", df1, ", ", df2, ") = ", F_val, "\n")

# Print the Tukey post-hoc test results
my_tukey
```

The Tukey post-hoc test compares the means of all pairwise combinations of groups and determines which groups are significantly different from each other. The output of the Tukey test provides the differences between each pair of means, along with a confidence interval and a p-value.

- Using the notation a < b < c, we can show the results of the Tukey test as follows:
    + The mean Sepal.Length of setosa (a) is significantly less than the mean of both versicolor (b) and virginica (c): a < b, a < c
    + The mean Sepal.Length of virginica (c) is significantly greater than the mean of both setosa (a) and versicolor (b): c > a, c > b
    + There is no significant difference between the mean Sepal.Length of versicolor (b) and virginica (c): b = c

Therefore, we can summarize the results of the Tukey test using the notation:

    setosa < versicolor
    setosa < virginica
    versicolor = virginica

```{r}
# Extract the mean differences, confidence intervals, and p-values
diffs <- my_tukey$`task`[, "diff"]
ci <- my_tukey$`task`[, c("lwr", "upr")]
pvals <- my_tukey$`task`[, "p adj"]

# Create a matrix to store the pairwise comparisons
results <- matrix("", nrow = 3, ncol = 3)

# Compare setosa to versicolor and virginica
results[1, 2] <- ifelse(diffs[1] < 0 & pvals[1] < 0.05, " < ", " = ")
results[1, 3] <- ifelse(diffs[2] < 0 & pvals[2] < 0.05, " < ", " = ")

# Compare virginica to setosa and versicolor
results[3, 1] <- ifelse(diffs[2] > 0 & pvals[2] < 0.05, " > ", " = ")
results[3, 2] <- ifelse(diffs[1] > 0 & pvals[1] < 0.05, " > ", " = ")

# Set versicolor equal to virginica
results[2, 1:3] <- " = "

# Add row and column names
rownames(results) <- c("task1", "task2", "task3")
colnames(results) <- c("task1", "task2", "task3")

# Print the results
results
```


```{r}
# # Set the mean and standard deviation
mean_value <- 85.1
std_value <- 6.9

set.seed(42)

random_numbers <- rnorm(36, mean = mean_value, sd = std_value)

for (number in random_numbers) {
  cat(number, "\n")
}

```



```{r}
reverse_function <- function(Total) {
  combined <- Total / 2.5
  average <- combined / 2
  X <- average - 5
  Y <- 25 - average
  p <- generate_numbers(X)
  q <- generate_numbers(Y)
  
  return(list(p = p, q = q))
}


generate_numbers <- function(desired_number) {
  # Check if desired_number is within valid range
  if (desired_number < 5 || desired_number > 25) {
    return("Invalid desired number. Please choose a number between 5 and 25.")
  }
  
  # Generate all possible combinations of 5 numbers
  combinations <- expand.grid(replicate(5, 1:5, simplify = FALSE))
  valid_combinations <- subset(combinations, rowSums(combinations) == desired_number)
  
  # Check if any valid combinations were found
  if (nrow(valid_combinations) == 0) {
    return("No valid combinations found for the desired number.")
  }
  
  # Return the first valid combination
  return(valid_combinations[1,])
}

# Example usage
# desired_number <- 25
# result <- generate_numbers(desired_number)
# print(result)

generate_numbers(17)


```