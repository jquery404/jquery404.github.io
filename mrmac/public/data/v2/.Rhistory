scale_y_discrete(expand = c(0, 1)) +
scale_fill_manual(values = c("#3c3c3c", "#666666", "#B5B5B5")) +
labs(title = "System Performance Chart", x = "Time in ms or FPS", y = "System Performance Metrics") +
theme_minimal() +
theme(axis.line = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
# Create the chart
ggplot(data, aes(x = value, y = metric, fill = test)) +
geom_col(position = position_dodge(width = .65), width = .45) +
scale_y_discrete(expand = c(0, 2)) +
scale_fill_manual(values = c("#3c3c3c", "#666666", "#B5B5B5")) +
labs(title = "System Performance Chart", x = "Time in ms or FPS", y = "System Performance Metrics") +
theme_minimal() +
theme(axis.line = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
1
# Create the chart
ggplot(data, aes(x = value, y = metric, fill = test)) +
geom_col(position = position_dodge(width = .65), width = .45) +
scale_y_discrete(expand = c(0, 1)) +
scale_fill_manual(values = c("#3c3c3c", "#666666", "#B5B5B5")) +
labs(title = "System Performance Chart", x = "Time in ms or FPS", y = "System Performance Metrics") +
theme_minimal() +
theme(axis.line = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
# Save the chart as a PDF file
ggsave("out/performance.pdf", width = 10, height = 7, unit = "in", dpi = 300)
# Generate sample data
set.seed(42)
sample_size <- 1000
timestamps <- seq(from = as.POSIXct("2023-01-01 00:00:00"), by = "10 min", length.out = sample_size)
latencies <- runif(sample_size, min = 10, max = 500)
data <- data.frame(timestamp = timestamps, latency = latencies)
# Convert the timestamp column to a proper date-time format
data$timestamp <- as.POSIXct(data$timestamp, format="%Y-%m-%d %H:%M:%S")
# Calculate the average, minimum, and maximum latency per time period (e.g., per hour)
latency_summary_data <- data %>%
group_by(time_period = floor_date(timestamp, "hour")) %>%
summarise(avg_latency = mean(latency, na.rm = TRUE),
min_latency = min(latency, na.rm = TRUE),
max_latency = max(latency, na.rm = TRUE))
# Generate sample data
set.seed(42)
sample_size <- 1000
timestamps <- seq(from = as.POSIXct("2023-01-01 00:00:00"), by = "10 min", length.out = sample_size)
latencies <- runif(sample_size, min = 10, max = 500)
data <- data.frame(timestamp = timestamps, latency = latencies)
# Convert the timestamp column to a proper date-time format
data$timestamp <- as.POSIXct(data$timestamp, format="%Y-%m-%d %H:%M:%S")
# Calculate the average, minimum, and maximum latency per time period (e.g., per hour)
latency_summary_data <- data %>%
group_by(time_period = floor_date(timestamp, "hour")) %>%
summarise(avg_latency = mean(latency, na.rm = TRUE),
min_latency = min(latency, na.rm = TRUE),
max_latency = max(latency, na.rm = TRUE))
# Create the combined latency chart using ggplot2
ggplot() +
geom_linerange(data = latency_summary_data, aes(x = time_period, ymin = min_latency, ymax = max_latency), color = "gray", alpha = 0.5) +
geom_line(data = latency_summary_data, aes(x = time_period, y = avg_latency), color = "blue") +
geom_point(data = latency_summary_data, aes(x = time_period, y = avg_latency), color = "blue") +
labs(title = "End-to-End Latency",
x = "Time Period",
y = "Latency (ms)") +
theme_minimal()
library(reshape2)
library(ggplot2)
library(dplyr)
library(lubridate)
library(reshape2)
library(ggplot2)
library(dplyr)
library(lubridate)
# Generate sample data
set.seed(42)
sample_size <- 1000
timestamps <- seq(from = as.POSIXct("2023-01-01 00:00:00"), by = "10 min", length.out = sample_size)
latencies <- runif(sample_size, min = 10, max = 500)
data <- data.frame(timestamp = timestamps, latency = latencies)
# Convert the timestamp column to a proper date-time format
data$timestamp <- as.POSIXct(data$timestamp, format="%Y-%m-%d %H:%M:%S")
# Calculate the average, minimum, and maximum latency per time period (e.g., per hour)
latency_summary_data <- data %>%
group_by(time_period = floor_date(timestamp, "hour")) %>%
summarise(avg_latency = mean(latency, na.rm = TRUE),
min_latency = min(latency, na.rm = TRUE),
max_latency = max(latency, na.rm = TRUE))
# Create the combined latency chart using ggplot2
ggplot() +
geom_linerange(data = latency_summary_data, aes(x = time_period, ymin = min_latency, ymax = max_latency), color = "gray", alpha = 0.5) +
geom_line(data = latency_summary_data, aes(x = time_period, y = avg_latency), color = "blue") +
geom_point(data = latency_summary_data, aes(x = time_period, y = avg_latency), color = "blue") +
labs(title = "End-to-End Latency",
x = "Time Period",
y = "Latency (ms)") +
theme_minimal()
dat <- read.table(text = "A   B   C
1 48 780 431
2 720 350 377
3 460 480 179
4 220 240 876", header = TRUE)
dat$row <- seq_len(nrow(dat))
dat2 <- melt(dat, id.vars = "row")
ggplot(dat2, aes(x = variable, y = value, fill = row)) +
geom_bar(stat = "identity") +
xlab("\nType") +
ylab("Time\n") +
coord_flip() +
theme_bw()
library(reshape2)
library(ggplot2)
library(dplyr)
library(lubridate)
dat <- read.table(text = "A   B   C
1 48 780 431
2 720 350 377
3 460 480 179
4 220 240 876", header = TRUE)
dat$row <- seq_len(nrow(dat))
dat2 <- melt(dat, id.vars = "row")
ggplot(dat2, aes(x = variable, y = value, fill = row)) +
geom_bar(stat = "identity") +
xlab("\nType") +
ylab("Time\n") +
coord_flip() +
theme_bw()
library(reshape2)
library(ggplot2)
library(dplyr)
library(lubridate)
dat <- read.table(text = "A   B   C
1 48 780 431
2 720 350 377
3 460 480 179
4 220 240 876", header = TRUE)
dat$row <- seq_len(nrow(dat))
dat2 <- melt(dat, id.vars = "row")
ggplot(dat2, aes(x = variable, y = value, fill = row)) +
geom_bar(stat = "identity") +
xlab("\nType") +
ylab("Time\n") +
coord_flip() +
theme_bw()
test  <- data.frame(person=c("A", "B", "C", "D", "E"),
value1=c(100,150,120,80,150),
value2=c(25,30,45,30,30) ,
value3=c(100,120,150,150,200))
melted <- melt(test, "person")
melted$cat <- ''
melted[melted$variable == 'value1',]$cat <- "local"
melted[melted$variable != 'value1',]$cat <- "remote"
ggplot(melted, aes(x = cat, y = value, fill = variable)) +
geom_bar(stat = 'identity', position = 'stack') + facet_grid(~ person)
# Set up the data
metrics <- c('Capturing/Processing Time', 'Encoding/Decoding Time', 'Transmission Time', 'Network Latency', 'Rendering FPS')
values <- list(c(45, 5, 50, 53, 80), c(60, 15, 60, 80, 65), c(75, 22, 71, 120, 59))
# Set up custom sorting order
custom_order <- c('Capturing/Processing Time',
'Encoding/Decoding Time',
'Transmission Time',
'Network Latency',
'Rendering FPS')
# Create a data frame
data <- data.frame(metric = factor(rep(metrics, 3), levels = custom_order),
value = unlist(values),
test = rep(c("C1", "C2", "C3"), each = length(metrics)))
# Create the chart
ggplot(data, aes(x = value, y = metric, fill = test)) +
geom_col(position = position_dodge(width = .65), width = .45) +
scale_y_discrete(expand = c(0, 1)) +
scale_fill_manual(values = c("#3c3c3c", "#666666", "#B5B5B5")) +
labs(title = "System Performance Chart", x = "Time in ms or FPS", y = "System Performance Metrics") +
theme_minimal() +
theme(axis.line = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
# Save the chart as a PDF file
ggsave("out/performance.pdf", width = 10, height = 7, unit = "in", dpi = 300)
library(reshape2)
library(ggplot2)
library(dplyr)
library(lubridate)
# Set up the data
metrics <- c('Capturing/Processing Time', 'Encoding/Decoding Time', 'Transmission Time', 'Network Latency', 'Rendering FPS')
values <- list(c(45, 5, 50, 53, 80), c(60, 15, 60, 80, 65), c(75, 22, 71, 120, 59))
# Set up custom sorting order
custom_order <- c('Capturing/Processing Time',
'Encoding/Decoding Time',
'Transmission Time',
'Network Latency',
'Rendering FPS')
# Create a data frame
data <- data.frame(metric = factor(rep(metrics, 3), levels = custom_order),
value = unlist(values),
test = rep(c("C1", "C2", "C3"), each = length(metrics)))
# Create the chart
ggplot(data, aes(x = value, y = metric, fill = test)) +
geom_col(position = position_dodge(width = .65), width = .45) +
scale_y_discrete(expand = c(0, 1)) +
scale_fill_manual(values = c("#3c3c3c", "#666666", "#B5B5B5")) +
labs(title = "System Performance Chart", x = "Time in ms or FPS", y = "System Performance Metrics") +
theme_minimal() +
theme(axis.line = element_blank(),
panel.grid.major.y = element_blank(),
panel.grid.minor.y = element_blank())
# Save the chart as a PDF file
ggsave("out/performance.pdf", width = 10, height = 7, unit = "in", dpi = 300)
dat <- read.table(text = "A   B   C
1 48 780 431
2 720 350 377
3 460 480 179
4 220 240 876", header = TRUE)
dat$row <- seq_len(nrow(dat))
dat2 <- melt(dat, id.vars = "row")
ggplot(dat2, aes(x = variable, y = value, fill = row)) +
geom_bar(stat = "identity") +
xlab("\nType") +
ylab("Time\n") +
coord_flip() +
theme_bw()
# Generate sample data
set.seed(42)
sample_size <- 1000
timestamps <- seq(from = as.POSIXct("2023-01-01 00:00:00"), by = "10 min", length.out = sample_size)
latencies <- runif(sample_size, min = 10, max = 500)
data <- data.frame(timestamp = timestamps, latency = latencies)
# Convert the timestamp column to a proper date-time format
data$timestamp <- as.POSIXct(data$timestamp, format="%Y-%m-%d %H:%M:%S")
# Calculate the average, minimum, and maximum latency per time period (e.g., per hour)
latency_summary_data <- data %>%
group_by(time_period = floor_date(timestamp, "hour")) %>%
summarise(avg_latency = mean(latency, na.rm = TRUE),
min_latency = min(latency, na.rm = TRUE),
max_latency = max(latency, na.rm = TRUE))
# Create the combined latency chart using ggplot2
ggplot() +
geom_linerange(data = latency_summary_data, aes(x = time_period, ymin = min_latency, ymax = max_latency), color = "gray", alpha = 0.5) +
geom_line(data = latency_summary_data, aes(x = time_period, y = avg_latency), color = "blue") +
geom_point(data = latency_summary_data, aes(x = time_period, y = avg_latency), color = "blue") +
labs(title = "End-to-End Latency",
x = "Time Period",
y = "Latency (ms)") +
theme_minimal()
my_data <- read.csv("csv/v2/demography.csv")
# Print the first few rows of the data
head(my_data)
row <- my_data[,1]
dims <- dim(my_data)
data <- data.frame(
Participant = 1:dims[1],
Age = my_data[,2],
Sex = my_data[,3],
Normal_Corrected = my_data[,4],
Interact = my_data[,5]
)
# Calculate descriptive statistics for age
summary(data$Age)
data=read.csv('csv/preference.csv', sep=",")
p <- ggplot(data, aes(x = conditions, y = score, fill = rank)) +
geom_bar(stat = 'identity', position = 'stack') +
coord_flip() +
theme_bw()
# Add labels to bars
p <- p + geom_text(aes(label = score), position = position_stack(vjust = 0.5), color = "black", size = 4)
# Add facet grid
p <- p + facet_grid(rows = vars(qus), switch = "y") +
# geom_signif(annotations = "*", y_position = 36.5, xmin="C1", xmax="C2") +
theme(strip.placement = "outside",
strip.background = element_rect(fill="#8b4819", color = NA))
# Apply the custom colors to the fill color of each factor level
p <- p + scale_fill_manual(values = coloring)
library(ggplot2)
library(dplyr)
library(ggpubr)
library(reshape2)
coloring = c("#E76469", "#F8D85E","#EDA645","#D1B0B3","#8C99A6","#ADD299","#4FA490","#3B7F9F")
fontsize = 14
preferences <- data.frame(
Condition = c("H1", "H2", "H3", "H4"),
R1 = c(2, 4, 1, 3), # Change these values to match the actual rankings in the study
R2 = c(4, 3, 2, 1), # Change these values to match the actual rankings in the study
R3 = c(3, 2, 4, 1), # Change these values to match the actual rankings in the study
R4 = c(1, 2, 3, 4) # Change these values to match the actual rankings in the study
)
data=read.csv('csv/preference.csv', sep=",")
p <- ggplot(data, aes(x = conditions, y = score, fill = rank)) +
geom_bar(stat = 'identity', position = 'stack') +
coord_flip() +
theme_bw()
# Add labels to bars
p <- p + geom_text(aes(label = score), position = position_stack(vjust = 0.5), color = "black", size = 4)
# Add facet grid
p <- p + facet_grid(rows = vars(qus), switch = "y") +
# geom_signif(annotations = "*", y_position = 36.5, xmin="C1", xmax="C2") +
theme(strip.placement = "outside",
strip.background = element_rect(fill="#8b4819", color = NA))
# Apply the custom colors to the fill color of each factor level
p <- p + scale_fill_manual(values = coloring)
# Add theme elements
p <- p + theme(axis.title.x=element_blank(),
axis.title.y = element_blank(),
plot.margin = unit(c(0, .05, .5, 0), "null"),
panel.border = element_blank(),
strip.text = element_text(face = "bold"),
legend.title=element_blank(),
legend.direction="horizontal",
legend.position = c(.5,-.05),
legend.justification = c("center", "top"))
# Show the plot
p
# saving the final figure
ggsave("out/preference.pdf", width = 7, height = 4, dpi = 1000)
# Add facet grid
p <- p + facet_grid(rows = vars(qus), switch = "y") +
# geom_signif(annotations = "*", y_position = 36.5, xmin="C1", xmax="C2") +
theme(strip.placement = "outside",
strip.background = element_rect(fill="#364651", color = NA))
data=read.csv('csv/preference.csv', sep=",")
p <- ggplot(data, aes(x = conditions, y = score, fill = rank)) +
geom_bar(stat = 'identity', position = 'stack') +
coord_flip() +
theme_bw()
# Add labels to bars
p <- p + geom_text(aes(label = score), position = position_stack(vjust = 0.5), color = "black", size = 4)
# Add facet grid
p <- p + facet_grid(rows = vars(qus), switch = "y") +
# geom_signif(annotations = "*", y_position = 36.5, xmin="C1", xmax="C2") +
theme(strip.placement = "outside",
strip.background = element_rect(fill="#364651", color = NA))
# Apply the custom colors to the fill color of each factor level
p <- p + scale_fill_manual(values = coloring)
# Add theme elements
p <- p + theme(axis.title.x=element_blank(),
axis.title.y = element_blank(),
plot.margin = unit(c(0, .05, .5, 0), "null"),
panel.border = element_blank(),
strip.text = element_text(face = "bold"),
legend.title=element_blank(),
legend.direction="horizontal",
legend.position = c(.5,-.05),
legend.justification = c("center", "top"))
# Show the plot
p
# saving the final figure
ggsave("out/preference.pdf", width = 7, height = 4, dpi = 1000)
data=read.csv('csv/preference.csv', sep=",")
p <- ggplot(data, aes(x = conditions, y = score, fill = rank)) +
geom_bar(stat = 'identity', position = 'stack') +
coord_flip() +
theme_bw()
# Add labels to bars
p <- p + geom_text(aes(label = score), position = position_stack(vjust = 0.5), color = "black", size = 4)
# Add facet grid
p <- p + facet_grid(rows = vars(qus), switch = "y") +
# geom_signif(annotations = "*", y_position = 36.5, xmin="C1", xmax="C2") +
theme(strip.placement = "outside",
strip.background = element_rect(fill="#364651", color = "#ffffff"))
# Apply the custom colors to the fill color of each factor level
p <- p + scale_fill_manual(values = coloring)
# Add theme elements
p <- p + theme(axis.title.x=element_blank(),
axis.title.y = element_blank(),
plot.margin = unit(c(0, .05, .5, 0), "null"),
panel.border = element_blank(),
strip.text = element_text(face = "bold"),
legend.title=element_blank(),
legend.direction="horizontal",
legend.position = c(.5,-.05),
legend.justification = c("center", "top"))
# Show the plot
p
# saving the final figure
ggsave("out/preference.pdf", width = 7, height = 4, dpi = 1000)
# Add theme elements
p <- p + theme(axis.title.x=element_blank(),
axis.title.y = element_blank(),
plot.margin = unit(c(0, .05, .5, 0), "null"),
panel.border = element_blank(),
strip.text = element_text(face = "bold", color = "white"),
legend.title=element_blank(),
legend.direction="horizontal",
legend.position = c(.5,-.05),
legend.justification = c("center", "top"))
data=read.csv('csv/preference.csv', sep=",")
p <- ggplot(data, aes(x = conditions, y = score, fill = rank)) +
geom_bar(stat = 'identity', position = 'stack') +
coord_flip() +
theme_bw()
# Add labels to bars
p <- p + geom_text(aes(label = score), position = position_stack(vjust = 0.5), color = "black", size = 4)
# Add facet grid
p <- p + facet_grid(rows = vars(qus), switch = "y") +
# geom_signif(annotations = "*", y_position = 36.5, xmin="C1", xmax="C2") +
theme(strip.placement = "outside",
strip.background = element_rect(fill="#364651", color = NA))
# Apply the custom colors to the fill color of each factor level
p <- p + scale_fill_manual(values = coloring)
# Add theme elements
p <- p + theme(axis.title.x=element_blank(),
axis.title.y = element_blank(),
plot.margin = unit(c(0, .05, .5, 0), "null"),
panel.border = element_blank(),
strip.text = element_text(face = "bold", color = "white"),
legend.title=element_blank(),
legend.direction="horizontal",
legend.position = c(.5,-.05),
legend.justification = c("center", "top"))
# Show the plot
p
# saving the final figure
ggsave("out/preference.pdf", width = 7, height = 4, dpi = 1000)
set.seed(123)  # Set a random seed for reproducibility
# Generate 10 random numbers between -5 and 5
x <- runif(10, min = -5, max = 5)
# Subtract the median from each of these numbers to center the distribution around 0
x <- x - median(x)
# Scale the data to have a mean of 45 and adjust the spread of the data
x <- x * (45 / mean(x)) * (20 / 10)^0.5
# Shift the median of the data to 55
x <- x + 55
# Repeat the data to create a vector of 20 observations
x <- rep(x, 2)
# Shuffle the vector to make the order of the observations random
x <- sample(x)
# View the resulting data set
x
set.seed(123) # Set a random seed for reproducibility
# Generate 10 random numbers between -5 and 5
x <- runif(10, min = -5, max = 5)
# Subtract the median from each of these numbers to center the distribution around 0
x <- x - median(x)
# Scale the data to have a mean of 45 and adjust the spread of the data
x <- x * (45 / mean(x)) * (20 / 10)^0.5
# Shift the median of the data to 55
x <- x + 55
# Round each observation to the nearest multiple of 5
x <- round(x/5) * 5
# Remove any observations outside the range of 0 to 100
x <- x[x >= 0 & x <= 100]
# If necessary, add additional observations to reach a total of 20
while (length(x) < 20) {
x <- c(x, round(runif(1, min = 0, max = 100)/5) * 5)
}
# Shuffle the vector to make the order of the observations random
x <- sample(x)
# View the resulting data set
x
set.seed(123) # Set a random seed for reproducibility
# Generate 10 random numbers between -18 and 18
x <- runif(10, min = -18, max = 18)
# Subtract the median from each of these numbers to center the distribution around 0
x <- x - median(x)
# Scale the data to have a mean of 22 and adjust the spread of the data
x <- x * (22 / mean(x)) * (20 / 10)^0.5
# Shift the median of the data to 40
x <- x + 40
# Round each observation to the nearest multiple of 5
x <- round(x/5) * 5
# Remove any observations outside the range of 0 to 100
x <- x[x >= 0 & x <= 100]
# If necessary, add additional observations to reach a total of 20
while (length(x) < 20) {
x <- c(x, round(runif(1, min = 0, max = 100)/5) * 5)
}
# Shuffle the vector to make the order of the observations random
x <- sample(x)
# View the resulting data set
x
set.seed(123) # Set a random seed for reproducibility
# Generate 10 random numbers between -15 and 15
x <- runif(10, min = -15, max = 15)
# Subtract the median from each of these numbers to center the distribution around 0
x <- x - median(x)
# Scale the data to have a mean of 35 and adjust the spread of the data
x <- x * (35 / mean(x)) * (20 / 10)^0.5
# Shift the median of the data to 50
x <- x + 50
# Round each observation to the nearest multiple of 5
x <- round(x/5) * 5
# Remove any observations outside the range of 0 to 100
x <- x[x >= 0 & x <= 100]
# If necessary, add additional observations to reach a total of 20
while (length(x) < 20) {
x <- c(x, round(runif(1, min = 0, max = 100)/5) * 5)
}
# Shuffle the vector to make the order of the observations random
x <- sample(x)
# View the resulting data set
x
set.seed(123) # Set a random seed for reproducibility
# Generate 10 random numbers between -5 and 5
x <- runif(10, min = -5, max = 5)
# Subtract the median from each of these numbers to center the distribution around 0
x <- x - median(x)
# Scale the data to have a mean of 45 and adjust the spread of the data
x <- x * (45 / mean(x)) * (20 / 10)^0.5
# Shift the median of the data to 55
x <- x + 55
# Round each observation to the nearest multiple of 5
x <- round(x/5) * 5
# Remove any observations outside the range of 0 to 100
x <- x[x >= 0 & x <= 100]
# If necessary, add additional observations to reach a total of 20
while (length(x) < 20) {
x <- c(x, round(runif(1, min = 0, max = 100)/5) * 5)
}
# Shuffle the vector to make the order of the observations random
x <- sample(x)
# View the resulting data set
x
