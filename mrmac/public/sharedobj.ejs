<html>
  <head>
    <meta charset="utf-8" />
    <title>shared</title>
    <meta name="description" content="shared" />

    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.3.0/socket.io.slim.js"></script>
    
    <script src="https://unpkg.com/networked-aframe@^0.7.1/dist/networked-aframe.min.js"></script>

    <script src="https://unpkg.com/super-hands/dist/super-hands.min.js"></script>
    <script src="https://unpkg.com/aframe-event-set-component@^4.0.0/dist/aframe-event-set-component.min.js"></script>

    <script src="https://cdn.jsdelivr.net/gh/n5ro/aframe-extras@14411ea/dist/aframe-extras.controls.min.js"></script>
    <script src="https://unpkg.com/aframe-environment-component@1.3.2/dist/aframe-environment-component.min.js"></script>
    <script>
      var blockobjs = [
        "#domino0",
        "#domino1",
        "#domino2",
        "#domino3",
        "#domino4",
        "#domino5",
        "#lego0",
        "#lego1",
        "#lego2",
        "#lego3",
        "#lego4",
        "#lego5",
        "#lego6",
        "#lego7",
      ];
      var idx = 0;

        AFRAME.registerComponent('shared-room', {
            schema: { 
                name: {type: 'string', default: 'Hello ðŸ‘‹'} 
            },

            init: function () {
              var el = this.el;
          
              // Setup networked-scene
              var networkedComp = {
                  room: 'nametag',
                  debug: true,
              };
              el.setAttribute('networked-scene', networkedComp);
            }
        });
        
        AFRAME.registerComponent('random-head', {
          schema: {
          },

          update: function () {
            if(Math.floor(Math.random()*2)%2)
              this.el.setAttribute('gltf-model', "#head1-glb")
            else
              this.el.setAttribute('gltf-model', "#head2-glb")
          }

        });
    
        AFRAME.registerComponent('rotation-control', {
          init: function() {
            this.el.addEventListener('intersected', this.onIntersect.bind(this));
          },

          onIntersect: function(evt) {
            var hand1 = document.querySelector('[super-hands]').components['super-hands'].selected;
            var hand2 = document.querySelector('[super-hands]').components['super-hands'].secondSelected;

            if (hand1 && hand2) {
              // Get the intersection points
              var point1 = hand1.getAttribute('position');
              var point2 = hand2.getAttribute('position');

              // Get the intersected object and its current rotation
              var object = evt.detail.el;
              var rotation = object.getAttribute('rotation');


              // Calculate the rotation angle based on the intersection points
              var diff = new THREE.Vector3().subVectors(point1, point2);
              var angle = Math.atan2(diff.x, diff.z);

              // Set the object's rotation
              object.setAttribute('rotation', { y: THREE.Math.radToDeg(angle) });
            }
          }
        });

        // Spawn in circle
        AFRAME.registerComponent('spawn-in-circle', {
            schema: {
                radius: {type: 'number', default: 1}
            },

            init: function() {
                var el = this.el;
                var center = el.getAttribute('position');

                var angleRad = this.getRandomAngleInRadians();
                var circlePoint = this.randomPointOnCircle(this.data.radius, angleRad);
                var worldPoint = {x: circlePoint.x + center.x, y: center.y, z: circlePoint.y + center.z};
                el.setAttribute('position', worldPoint);
                // console.log('world point', worldPoint);

                var angleDeg = angleRad * 180 / Math.PI;
                var angleToCenter = -1 * angleDeg + 90;
                angleRad = THREE.MathUtils.degToRad(angleToCenter);
                el.object3D.rotation.set(0, angleRad, 0);
                // console.log('angle deg', angleDeg);
            },

            getRandomAngleInRadians: function() {
                return Math.random()*Math.PI*2;
            },

            randomPointOnCircle: function (radius, angleRad) {
                var x = Math.cos(angleRad)*radius;
                var y = Math.sin(angleRad)*radius;
                return {x: x, y: y};
            }
        });

        AFRAME.registerComponent('toggleownership', {
          schema: {
            speed: { default: 0.01 },
            direction: { default: 1 },
            canDrag:{default: false},
          },

          init() {
            var that = this;
            this.onKeyUp = this.onKeyUp.bind(this);
            document.addEventListener('keyup', this.onKeyUp);

            

            NAF.utils.getNetworkedEntity(this.el).then((el) => {
              // if (!NAF.utils.isMine(el)) {
              //   that.updateOpacity(0.5);
              // }

              // Opacity is not a networked attribute, but change it based on ownership events
              let timeout;

              el.addEventListener('ownership-gained', e => {
                that.updateOpacity(1);
              });

              el.addEventListener('ownership-lost', e => {
                that.updateOpacity(0.5);
              });

              el.addEventListener('ownership-changed', e => {
                clearTimeout(timeout);
                console.log(e.detail)
                if (e.detail.newOwner == NAF.clientId) {
                  //same as listening to 'ownership-gained'
                } else if (e.detail.oldOwner == NAF.clientId) {
                  //same as listening to 'ownership-lost'
                } else {
                  that.updateOpacity(0.8);
                  timeout = setTimeout(() => {
                    that.updateOpacity(0.5);
                  }, 200)
                }
              });
            });
          },

          onKeyUp(e) {
            if (e.keyCode !== 13 /* enter */) {
              return;
            }

            if(NAF.utils.takeOwnership(this.el)) {
              this.el.setAttribute('toggleownership', { direction: this.data.direction * -1 });
            }else{
              this.updateOpacity(1);
            }
          },

          updateOpacity(opacity) {
            this.el.setAttribute('material', 'opacity', opacity);
          },

          tick() {

            if(this.data.canDrag){
              console.log("hi");
              if(NAF.utils.takeOwnership(this.el)) {
                console.log("taking ownership");
                this.el.setAttribute('toggleownership', { direction: this.data.direction * -1 });
              }
              else{
                console.log("already owner or failed");
              }
              this.data.canDrag = false;
            }
            // Only update the component if you are the owner.
            if (!NAF.utils.isMine(this.el)) {
              return;
            }

            // this.el.object3D.rotateY(this.data.speed * this.data.direction);

            // const rotation = this.el.object3D.rotation;
            // this.el.setAttribute('rotation', {
            //   x: THREE.Math.radToDeg(rotation.x),
            //   y: THREE.Math.radToDeg(rotation.y),
            //   z: THREE.Math.radToDeg(rotation.z),
            // });
          }
        });
          
        AFRAME.registerComponent('spawner', {
          schema: {
            template: { default: '' },
            keyCode: { default: 32 },
            start: { default: false } 
          },

          init: function() {
            this.onKeyUp = this.onKeyUp.bind(this);
            document.addEventListener("keyup", this.onKeyUp);
          },

          onKeyUp: function(e) {
            if (this.data.keyCode === e.keyCode) {
              var el = document.createElement('a-entity');
              el.setAttribute('networked', 'template:' + this.data.template);
              el.setAttribute('position', this.el.getAttribute('position'));
              var scene = this.el.sceneEl;
              scene.appendChild(el);
            }
          },

          removeObject: function() {
            var el = this.el;
            el.parentNode.removeChild(el);
          },

          tick: function () {

            this.el.object3D.rotateY(0.01 * 1);

            const rotation = this.el.object3D.rotation;
            this.el.setAttribute('rotation', {
              x: THREE.Math.radToDeg(rotation.x),
              y: THREE.Math.radToDeg(rotation.y),
              z: THREE.Math.radToDeg(rotation.z),
            });

            if(this.data.start){
              for (let i = 0; i < blockobjs.length; i++) {
                var el = document.createElement('a-entity');
                el.setAttribute('networked', 'template:' + this.data.template);
                el.setAttribute('position', this.el.getAttribute('position'));
                var scene = this.el.sceneEl;
                scene.appendChild(el);
              }
              this.data.start = false;
              this.removeObject();
            }
          
            if(document.querySelectorAll(".cube").length){
              this.removeObject();
            }
          }
        });

        AFRAME.registerComponent('rigidbody', {
          schema: {
            model: {default: ''}
          },

          init: function () {
            this.el.setAttribute('gltf-model', blockobjs[idx]);
            this.el.setAttribute('scale', '.1 .1 .1');
            this.el.setAttribute('hoverable', '');
            this.el.setAttribute('grabbable', '');
            this.el.setAttribute('stretchable', '');
            this.el.setAttribute('draggable', '');
            this.el.setAttribute('droppable', '');
            idx++;
          }

        });
    
    </script>

    <script>
      // Temporary workaround for template declaration; see issue 167
      NAF.schemas.getComponentsOriginal = NAF.schemas.getComponents;
      NAF.schemas.getComponents = (template) => {
        if (!NAF.schemas.hasTemplate('#head-template')) {
          NAF.schemas.add({
            template: '#head-template',
            components: [
              'position',
              'rotation',
              'player-info',
              {
                selector: '.head',
                component: 'gltf-model',
              }
            ]
          });
        }

        if (!NAF.schemas.hasTemplate('#cube-template')) {
          NAF.schemas.add({
            template: '#cube-template',
            components: [
              'position',
              {
                selector: '.cube',
                component: 'position'
              },
              {
                selector: '.cube',
                component: 'rotation'
              },
            ]
          });
        }

        const components = NAF.schemas.getComponentsOriginal(template);
        return components;
      };
    </script>

    <script>
      window.ntExample = {
        randomColor: () => {
          return '#' + new THREE.Color(Math.random(), Math.random(), Math.random()).getHexString();
        }
      };

      AFRAME.registerComponent('player-info', {
        schema: {
          name: { type: 'string', default: 'user-' + Math.round(Math.random() * 10000) },
          color: {
            type: 'color',
            default: window.ntExample.randomColor()
          }
        },

        init: function () {
          this.head = this.el.querySelector('.head');
          this.nametag = this.el.querySelector('.nametag');

          this.ownedByLocalUser = this.el.id === 'player';
          if (this.ownedByLocalUser) {
            // populate the html overlay with the correct name on init
            this.nametagInput = document.getElementById('username-overlay');
            this.nametagInput.value = this.data.name;

            // add the initial color to the html overlay color picker button
            document.querySelector('button').style.backgroundColor = this.data.color;
            document.querySelector('button').style.color = this.data.color;
          }
        },

        // here as an example, not used in current demo. Could build a user list, expanding on this.
        listUsers: function () {
          console.log(
            'userlist',
            [...document.querySelectorAll('[player-info]')].map((el) => el.components['player-info'].data.name)
          );
        },

        newRandomColor: function () {
          this.el.setAttribute('player-info', 'color', window.ntExample.randomColor());
          this.listUsers();
        },

        update: function () {
          if (this.head) this.head.setAttribute('material', 'color', this.data.color);
          if (this.nametag) this.nametag.setAttribute('value', this.data.name);
        }
      });
    </script>
  </head>

  <body>
    <button
      id="color-changer"
      style="z-index: 100; bottom: 24px; left: 24px; position: fixed"
      onclick="let newColor = window.ntExample.randomColor();
             document.getElementById('player').setAttribute('player-info', 'color', newColor); 
             document.querySelector('button').style.backgroundColor = newColor;
             document.querySelector('button').style.color = newColor;
    "
    >
      â– 
    </button>
    <input
      id="username-overlay"
      style="z-index: 100; bottom: 24px; left: 48px; position: fixed"
      oninput="document.getElementById('player').setAttribute('player-info', 'name', this.value)"
    />

    <a-scene shared-room>
      <a-assets>
        <a-asset-item id="head1-glb" src="<%= _url %>/model/_avatars/gg_head.glb"></a-asset-item>
        <a-asset-item id="body1-glb" src="<%= _url %>/model/_avatars/male_body.glb"></a-asset-item>
        <a-asset-item id="head2-glb" src="<%= _url %>/model/_avatars/aa_head.glb"></a-asset-item>
        <a-asset-item id="body2-glb" src="<%= _url %>/model/_avatars/female_body.glb"></a-asset-item>
        <a-asset-item id="head3-glb" src="<%= _url %>/model/_avatars/curious_boy_black_head.glb"></a-asset-item>
        <a-asset-item id="body3-glb" src="<%= _url %>/model/_avatars/curious_boy_default_body.glb"></a-asset-item>
        <%- include('_ass_lego_domino'); %>

        <a-mixin id="startBtn" geometry="primitive: box; width: 0.5; height: 0.5; depth: 0.5"
                 hoverable 
                 event-set__click="_event: click; spawner.start: true;"
                 event-set__hoveron="_event: hover-start; material.opacity: 0.7; transparent: true"
                 event-set__hoveroff="_event: hover-end; material.opacity: 1; transparent: false">
        </a-mixin>

        <a-mixin id="pointer" raycaster="showLine: true; objects: .cube, .btn, a-link"
                  super-hands="colliderEvent: raycaster-intersection;
                               colliderEventProperty: els;
                               colliderEndEvent:raycaster-intersection-cleared;
                               colliderEndEventProperty: clearedEls;">
        </a-mixin>
        <a-mixin id="controller-right" mixin="pointer"
                 vive-controls="hand: right" oculus-touch-controls="hand: right"
                 windows-motion-controls="hand: right"
                 gearvr-controls daydream-controls oculus-go-controls>
        </a-mixin>
        <a-mixin id="controller-left" mixin="pointer"
                 vive-controls="hand: left" oculus-touch-controls="hand: left"
                 windows-motion-controls="hand: left">
        </a-mixin>
        <a-mixin id="cube" rigidbody event-set__hoveron="_event: click; toggleownership.canDrag: true;">
        </a-mixin>
        <template id="cube-template">
          <a-entity>
            <a-entity class="cube" toggleownership mixin="cube" position="0 1 -1.25" material="color: red"></a-entity>
          </a-entity>
        </template>
        
        <template id="rig-template">
          <a-entity></a-entity>
        </template>

        <template id="head-template">
          <a-entity class="avatar" player-info>
            <a-entity class="head" gltf-model="#head1-glb"></a-entity>
            <a-entity class="body" gltf-model="#body2-glb"></a-entity>

            <!-- here we add a text component for a nametag; the value will be updated by the player-info component -->
            <a-text
              class="nametag"
              value="?"
              color="#fff"
              rotation="0 180 0"
              position=".25 -.35 0"
              side="double"
              scale=".5 .5 .5"
            ></a-text>
          </a-entity>
        </template>
      </a-assets>

      <a-entity class="btn" spawner="template:#cube-template" mixin="startBtn" position="2 1 -2" material="color: red">
        <a-text value="START" color="#000" align="center" rotation="0 180 0" position="0 .3 0" side="double" scale=".5 .5 .5"></a-text>
      </a-entity>

      <a-entity environment="preset:forest;groundColor:#A99F47;"></a-entity>
      <a-entity light="type:ambient;intensity:0.5"></a-entity>


      <!-- on desktop -->
      <!-- <a-entity id="rig" movement-controls="fly:true;" spawn-in-circle="radius:3" networked="template:#rig-template;">
        <a-entity
          id="player"
          camera
          capture-mouse
          raycaster="objects: .cube, .btn" cursor="rayOrigin:mouse"
          static-body="shape: sphere; sphereRadius: 0.001"
          super-hands="colliderEvent: raycaster-intersection;
                        colliderEventProperty: els;
                        colliderEndEvent:raycaster-intersection-cleared;
                        colliderEndEventProperty: clearedEls;"
          position="0 1.6 0"
          networked="template:#head-template;"
          visible="false"
        ></a-entity>
      </a-entity> -->


      <!-- on vr hmd -->
      <a-entity id="rig" spawn-in-circle="radius:2" networked="template:#rig-template;">
        <a-entity
          id="player"
          camera
          look-controls
          raycaster="objects: .cube, .btn"
          static-body="shape: sphere; sphereRadius: 0.001"
          super-hands="colliderEvent: raycaster-intersection;
                        colliderEventProperty: els;
                        colliderEndEvent:raycaster-intersection-cleared;
                        colliderEndEventProperty: clearedEls;"
          position="0 1.6 0"
          networked="template:#head-template;"
          visible="false"
        ></a-entity>
        <a-entity id="rhand" mixin="controller-right"></a-entity>
        <a-entity id="lhand" mixin="controller-left"></a-entity>
      </a-entity>
      
      
    </a-scene>
  </body>
</html>